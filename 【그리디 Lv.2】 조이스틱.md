# 조이스틱 (프로그래머스 문제 Lv 2)

![image](https://user-images.githubusercontent.com/39308313/145410074-c79c5eec-a46b-46a5-a5cb-79cf384b10d3.png)

## 풀이 과정

### 알파벳을 입력할 때 처리할 계산은 두 가지이다.
 - 위, 아래로 스틱을 몇 번 움직여야 하는가?
 - 어떻게 해야 옆으로 적게 움직이는가?

```txt
1. 
위 아래로 몇 번 움직여야하는지 먼저 구하자.

2. 
JAZ가 입력됐을 때 A는 움직일 필요가 없으니 0이다.
J는 A에서 9번 위로 움직여야 한다. A + 9다.
Z는 A에서 1번 아래로 움직여야 한다. A - 1이다.

2-1. 
알파벳은 총 26개다. 13번 이상 위로 올릴 거면 아래로 내리는 게 빠르다.
알파벳을 charCode로 바꾼다. 그냥 바꾸면 74, 65, 90같은 숫자가 나온다.
알파벳 대문자는 65~90까지다. 모든 charCode에서 65를 빼면 된다.
2-1의 조건을 만족하기 위해 가운데 숫자 78을 넘는 알파벳은 91 - charCode를 한다.

3. 
모든 숫자들의 합 sum을 구한다.

4.
111011처럼 0이 4번에 있으면 3번까지 이동한 거리만큼은 이득을 얻어야 한다.

5.
1110111100000011111에 대해,
i = 4일 때 0이 1개 있다.
0의 count는 1이다.
이동한 거리는 3이므로 i - 1이다.
0을 포함해서 이동했으므로, count * 2만큼 뺀다.
따라서 이 지점에서 후퇴했을 땐 3 - 2 = 1만큼 추가 이동거리가 발생한다.
후퇴하는 게 손해이므로 min에는 저장하지 않는다.

i = 8일 때 0이 나오므로 count 변수로 0을 다 센다.
위와 같은 과정을 거쳐서 0을 다 센 다음의 변수들은
이동한 거리 : (i - 1) = 13
0의 갯수 : count = 6
13 - 12 = 1이므로 이 경우에도 후퇴하면 이득이 없다. min에는 저장하지 않는다.

6. 마지막 인덱스까지 진행하고 min + sum을 return한다.


※ 단, 이 풀이는 앞만 보며 달린다. 눈 앞의 이득만 보고 달리는 방법이다.

"BBBBBBAAAAB"처럼 뒤로 돌았다가 다시 돌아오는 게 더 이득인 케이스는 풀리지 않는다.
```

### 코드 구현

```javascript
function solution(name) {
	// "JAZ" => ['J','A','Z'] => [74, 65, 90] => [9,0,25] => [9,0,1]로 만듭니다.
	const parse = n => (n <= 78 ? n - 65 : 91 - n);
	name = name.split("").map(s => parse(s.charCodeAt(0)));
	const sum = name.reduce((a, b) => a + b + 1);

	let min = 0, count = 0, temp = 0;
	for (let i = 1; i < name.length; i++) {
		if (name[i] !== 0) {
			temp = (i-1) - count;
			min = min > temp ? temp : min;
			count = 0;
		} else {
			count += 2;
		}
	}
	return sum + min;
}
```

[출처 : 프로그래머스 조이스틱](https://programmers.co.kr/learn/courses/30/lessons/42860)
